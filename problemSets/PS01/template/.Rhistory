h <- k - n * D
m <- 2 * k - 1
H <- create_matrix_H(h, m)
# Compute H to the power of n
T <- H
if (n > 1) {
for (i in 2:n) {
T <- T %*% H
}
}
# Calculate p-value
p_value <- factorial(n) * T[k, k] / n^n
if (is.nan(p_value) || p_value > 1) {
p_value <- 1  # Adjust p-value if it's NaN or greater than 1
}
return(p_value)
}
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
theoreticalCDF <- pnorm(data)
D <- max(abs(empiricalCDF - theoreticalCDF))
# Calculate the p-value
p_value <- ks_pvalue_matrix(D, n)
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Print the result
print(ks_result)
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
D <- max(abs(empiricalCDF - theoreticalCDF))
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
for (i in 1:m) {
for (j in 1:i) {
if (j == 1) {
H[i, j] <- (1 - h^(i-1)) / factorial(i-1)
} else {
H[i, j] <- (1 - h^(i+1-j)) / factorial(i+1-j)
}
}
}
T <- H
for (i in 2:n) {
T <- T %*% H
}
p_value <- factorial(n) * T[k, k] / n^n
return(p_value)
}
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
for (i in 1:m) {
for (j in 1:i) {
if (j == 1) {
H[i, j] <- (1 - h^(i-1)) / factorial(i-1)
} else {
H[i, j] <- (1 - h^(i+1-j)) / factorial(i+1-j)
}
}
}
T <- H
for (i in 2:n) {
T <- T %*% H
}
p_value <- factorial(n) * T[k, k] / n^n
return(p_value)
}
D <- max(abs(empiricalCDF - theoreticalCDF))
p_value <- ks_pvalue_matrix(D, n)
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Print the result
print(ks_result)
# Set the seed for reproducibility
set.seed(123)
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
H <- create_matrix_H(k, h)
T <- H
# Fill the matrix
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
for (i in 1:m) {
for (j in 2:i) {
H[i, j] <- (1-h^(i+1-j)) / factorial(i+1-j)
}
}
for (i in 1:(m-1)) {
for (j in 1) {
H[i, j] <- (1-h^i) / factorial(i)
}
}
for (i in 1:m) {
for (j in 1) {
H[i, j] <- (1-2*h^i) / factorial(i)
}
}
for (i in 2:(m-1)) {
for (j in 1:i) {
if (i+1 <= j) {
H[i, j] <- 1 / factorial(i+1-j)
} else {
H[i, j] <- 0
}
}
}
for (i in 2:n) {
T <- T %*% H
}
p_value <- factorial(n) * T[k, k] / n^n
return(p_value)
}
D <- max(abs(empiricalCDF - theoreticalCDF))
p_value <- ks_pvalue_matrix(D, n)
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Print the result
print(ks_result)
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
H <- create_matrix_H(k, h)
T <- H
# Fill the matrix
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
for (i in 1:m) {
for (j in 2:i) {
H[i, j] <- (1-h^(i+1-j)) / factorial(i+1-j)
}
}
for (i in 1:(m-1)) {
for (j in 1) {
H[i, j] <- (1-h^i) / factorial(i)
}
}
for (i in 1:m) {
for (j in 1) {
H[i, j] <- (1-2*h^i) / factorial(i)
}
}
for (i in 2:(m-1)) {
for (j in 1:i) {
if (i+1 <= j) {
H[i, j] <- 1 / factorial(i+1-j)
} else {
H[i, j] <- 0
}
}
}
for (i in 2:n) {
T <- T %*% H
}
p_value <- factorial(n) * T[k, k] / n^n
return(p_value)
}
D <- max(abs(empiricalCDF - theoreticalCDF))
p_value <- ks_pvalue_matrix(D, n)
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
Problem
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
T <- H
# Fill the matrix
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
for (i in 1:m) {
for (j in 2:i) {
H[i, j] <- (1-h^(i+1-j)) / factorial(i+1-j)
}
}
for (i in 1:(m-1)) {
for (j in 1) {
H[i, j] <- (1-h^i) / factorial(i)
}
}
for (i in 1:m) {
for (j in 1) {
H[i, j] <- (1-2*h^i) / factorial(i)
}
}
for (i in 2:(m-1)) {
for (j in 1:i) {
if (i+1 <= j) {
H[i, j] <- 1 / factorial(i+1-j)
} else {
H[i, j] <- 0
}
}
}
for (i in 2:n) {
T <- T %*% H
}
p_value <- factorial(n) * T[k, k] / n^n
return(p_value)
}
D <- max(abs(empiricalCDF - theoreticalCDF))
p_value <- ks_pvalue_matrix(D, n)
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Print the result
print(ks_result)
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
# Fill the matrix
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
for (i in 1:m) {
for (j in 2:i) {
H[i, j] <- (1-h^(i+1-j)) / factorial(i+1-j)
}
}
for (i in 1:(m-1)) {
for (j in 1) {
H[i, j] <- (1-h^i) / factorial(i)
}
}
for (i in 1:m) {
for (j in 1) {
H[i, j] <- (1-2*h^i) / factorial(i)
}
}
for (i in 2:(m-1)) {
for (j in 1:i) {
if (i+1 <= j) {
H[i, j] <- 1 / factorial(i+1-j)
} else {
H[i, j] <- 0
}
}
}
T <- H
for (i in 2:n) {
T <- T %*% H
}
p_value <- factorial(n) * T[k, k] / n^n
return(p_value)
}
D <- max(abs(empiricalCDF - theoreticalCDF))
p_value <- ks_pvalue_matrix(D, n)
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Print the result
print(ks_result)
H[i, j] <- 0
if (i+1 <= j) {
H[i, j] <- 1 / factorial(i+1-j)
} else {
H[i, j] <- 0
}
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
# Fill the matrix
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
for (i in 1:m) {
for (j in 2:i) {
H[i, j] <- (1-h^(i+1-j)) / factorial(i+1-j)
}
}
for (i in 1:(m-1)) {
for (j in 1) {
H[i, j] <- (1-h^i) / factorial(i)
}
}
for (i in 1:m) {
for (j in 1) {
H[i, j] <- (1-2*h^i) / factorial(i)
}
}
for (i in 2:(m-1)) {
for (j in 1:i) {
if (i+1 <= j) {
H[i, j] <- 1 / factorial(i+1-j)
} else {
H[i, j] <- 0
}
}
}
T <- H
for (i in 2:n) {
T <- T %*% H
}
p_value <- factorial(n) * T[k, k] / n^n
return(p_value)
}
D <- max(abs(empiricalCDF - theoreticalCDF))
p_value <- ks_pvalue_matrix(D, n)
return(list(D = D, p_value = p_value))
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Print the result
print(ks_result)
# Set the seed for reproducibility
set.seed(123)
# Create the data
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75 * data$x + rnorm(200, 0, 1.5)
# Estimate the OLS regression using lm()
lm_fit <- lm(y ~ x, data = data)
# Now using optim() to perform OLS manually using the BFGS method
# Define the objective function (sum of squared residuals)
ssr <- function(params, data) {
with(data, sum((y - (params[1] + params[2] * x))^2))
}
# Initial parameter guesses
initial_params <- c(0, 0)
# Run optim() with BFGS method
optim_fit <- optim(par = initial_params, fn = ssr, data = data, method = "BFGS")
# Show the coefficients from lm and optim
lm_coefficients <- coef(lm_fit)
optim_coefficients <- optim_fit$par
# Print the results
print(lm_coefficients)
print(optim_coefficients)
# Function to perform the KS test
ks_test <- function(data) {
n <- length(data)
# Sort data for ECDF calculation
data <- sort(data)
ECDF <- ecdf(data)
empiricalCDF <- ECDF(data)
# Theoretical CDF for the standard normal distribution
theoreticalCDF <- pnorm(data)
# Calculate the KS statistic D
D <- max(abs(empiricalCDF - theoreticalCDF))
# Calculate the p-value using matrix H
p_value <- ks_pvalue_matrix(D, n)
# Return the KS statistic and p-value
return(list(D = D, p_value = p_value))
}
# Function to calculate the p-value using matrix H
ks_pvalue_matrix <- function(D, n) {
k <- ceiling(n * D)
h <- k - n * D
m <- 2 * k - 1
# Initialize the matrix H
H <- matrix(0, nrow = m, ncol = m)
# Fill the matrix H according to the rules
for (i in 1:m) {
H[i, 1] <- (1 - h^(i-1)) / factorial(i-1)  # First column
if (i > 1) {
H[i, i] <- (1 - h) / factorial(1)  # Diagonal
}
for (j in 2:(i-1)) {
H[i, j] <- (1 - h^(j-1)) / factorial(j-1)  # Off-diagonal
}
}
# Adjust the last row of matrix H for h > 0.5
if (h > 0.5) {
H[m, 1:m] <- rev(H[1:m, 1])  # Reflect the first column
H[m, 1] <- (1 - 2 * h^m + max(0, 2 * h - 1)^m) / factorial(m)  # Bottom left corner
}
# Compute the n-th power of matrix H
T <- H
for (i in 2:n) {
T <- T %*% H
}
# The k,k element of matrix T
t_kk <- T[k, k]
# Compute the p-value
p_value <- factorial(n) / n^n * t_kk
return(p_value)
}
# Set seed for reproducibility
set.seed(123)
# Generate 1,000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Perform the KS test
ks_result <- ks_test(cauchy_data)
# Print the result
print(ks_result)
